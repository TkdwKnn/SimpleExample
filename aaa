Привет! Отличный настрой! Разобраться с файловой системой и правами доступа — это как научиться читать "мелкий шрифт" в Linux. Это фундаментальные вещи, которые откроют тебе совершенно новый уровень контроля над системой.

Давай разложим всё по полочкам, как ты и просил: просто, детально и с примерами.

### Часть 1: Ссылки в Linux (Links)

Представь себе, что у тебя есть важный документ. В Windows ты можешь создать для него "Ярлык" на рабочем столе. Ссылки в Linux — это похожая, но гораздо более мощная концепция.

Основная идея ссылки — **позволить одному файлу или папке быть доступными по разным именам или из разных мест.**

Есть два типа ссылок:
1.  **Символические (Symbolic / Soft Links)** — "ярлыки".
2.  **Жесткие (Hard Links)** — "вторые имена".

Давай подробно о каждой.

#### 1. Символические ссылки (Symbolic Links, они же "симлинки" или "мягкие" ссылки)

Это самый простой и интуитивно понятный тип. Симлинк — это **маленький специальный файл, который содержит в себе путь к другому файлу или папке.**

**Аналогия:** Ярлык на рабочем столе Windows или закладка в браузере. Она просто указывает, где находится оригинал.

**Ключевые свойства:**
*   Это отдельный файл. У него есть свои метаданные.
*   Если удалить **оригинал**, ссылка станет "битой" (dangling link) — она будет указывать в никуда и перестанет работать.
*   Если удалить **ссылку**, с оригиналом ничего не произойдет.
*   Можно создавать ссылки на **папки**.
*   Можно создавать ссылки на файлы, которые находятся на **других дисках** или сетевых хранилищах (других файловых системах).

**Как создать?**
Команда `ln` (от слова link) с флагом `-s` (symbolic).

```bash
ln -s [путь_к_оригиналу] [имя_новой_ссылки]
```

**Пример:**

1.  Создадим файл с каким-нибудь текстом.
    ```bash
    # Создаем файл и записываем в него текст
    echo "Это мой секретный документ" > /home/user/documents/secret.txt
    ```

2.  Теперь создадим на него символическую ссылку на рабочем столе.
    ```bash
    # Переходим на рабочий стол (или в любую другую папку)
    cd /home/user/desktop

    # Создаем символическую ссылку
    ln -s /home/user/documents/secret.txt my_secret_link.txt
    ```

3.  Давай посмотрим, что получилось, с помощью команды `ls -l`:
    ```bash
    ls -l
    ```
    Ты увидишь что-то вроде этого:
    ```
    lrwxrwxrwx 1 user user 29 окт 26 15:00 my_secret_link.txt -> /home/user/documents/secret.txt
    ```
    **Что это значит:**
    *   `l` в самом начале `lrwxrwxrwx` говорит, что это **link** (символическая ссылка).
    *   `->` явно показывает, куда эта ссылка указывает.

4.  Теперь, если ты прочитаешь содержимое ссылки, ты увидишь содержимое оригинала:
    ```bash
    cat my_secret_link.txt
    # Вывод: Это мой секретный документ
    ```

5.  А что будет, если удалить оригинал?
    ```bash
    rm /home/user/documents/secret.txt
    cat my_secret_link.txt
    # Вывод: cat: my_secret_link.txt: No such file or directory
    ```
    Ссылка "сломалась". `ls -l` покажет её красным цветом (в большинстве терминалов), сигнализируя о проблеме.

---

#### 2. Жесткие ссылки (Hard Links)

Это более сложная, но и более "низкоуровневая" концепция. Жесткая ссылка — это **не новый файл, а новое имя для уже существующего файла.**

Чтобы понять это, нужно знать, что такое **inode** (индексный дескриптор). Представь, что у каждого файла на диске есть свой "паспорт" — это и есть inode. В этом паспорте записано всё о файле: его размер, права доступа, владелец, и, самое главное, **где физически на диске лежат его данные**. А имя файла (например, `secret.txt`) — это всего лишь запись в папке, которая ссылается на этот "паспорт" (inode).

Жесткая ссылка создает **вторую запись в файловой системе, которая указывает на тот же самый inode**.

**Аналогия:** У человека есть официальное имя (Иван Иванов) и прозвище (Вано). Оба имени относятся к одному и тому же человеку. Если вычеркнуть одно имя из записной книжки, человек никуда не денется.

**Ключевые свойства:**
*   Это не отдельный файл. Это просто еще одно имя для тех же данных на диске.
*   Если удалить **оригинал** (первое имя), файл не удаляется! Он будет доступен по второму имени (жесткой ссылке). Данные с диска будут стерты только тогда, когда будет удалена **последняя** жесткая ссылка на этот inode.
*   Нельзя создавать жесткие ссылки на **папки** (это сделано во избежание создания бесконечных циклов в файловой системе).
*   Нельзя создавать жесткие ссылки на файлы на **другом диске** (потому что у каждого диска своя таблица inode).

**Как создать?**
Команда `ln` **без** флага `-s`.

```bash
ln [путь_к_оригиналу] [имя_новой_ссылки]
```

**Пример:**

1.  Вернем наш файл.
    ```bash
    echo "Это тот же самый документ" > /home/user/documents/original.txt
    ```

2.  Создадим на него жесткую ссылку.
    ```bash
    cd /home/user/desktop
    ln /home/user/documents/original.txt hard_link.txt
    ```

3.  Смотрим через `ls -l`:
    ```bash
    ls -l /home/user/documents/original.txt /home/user/desktop/hard_link.txt
    ```
    Вывод будет примерно таким:
    ```
    -rw-rw-r-- 2 user user 27 окт 26 15:10 /home/user/desktop/hard_link.txt
    -rw-rw-r-- 2 user user 27 окт 26 15:10 /home/user/documents/original.txt
    ```
    **Обрати внимание:**
    *   Никаких `l` и `->`. Система считает их равноправными файлами.
    *   **Цифра `2`** после прав доступа (`-rw-rw-r--`). Это **счетчик жестких ссылок**! Он показывает, сколько имен ссылается на этот inode.

4.  Давай изменим один из файлов и посмотрим на второй.
    ```bash
    echo " - и я его дополнил" >> /home/user/desktop/hard_link.txt
    cat /home/user/documents/original.txt
    # Вывод: Это тот же самый документ - и я его дополнил
    ```
    Поскольку это один и тот же файл, изменения отражаются везде.

5.  А теперь самое интересное — удалим "оригинал".
    ```bash
    rm /home/user/documents/original.txt
    ```
    Проверяем, что осталось:
    ```bash
    cat /home/user/desktop/hard_link.txt
    # Вывод: Это тот же самый документ - и я его дополнил
    ```
    Файл на месте! Он все еще работает. А если посмотреть на него через `ls -l`:
    ```bash
    ls -l /home/user/desktop/hard_link.txt
    # -rw-rw-r-- 1 user user 48 окт 26 15:12 /home/user/desktop/hard_link.txt
    ```
    Счетчик ссылок уменьшился до `1`. Файл будет окончательно удален, когда этот счетчик станет равен нулю.

#### Сводка и "Фишки" по ссылкам

| Характеристика | Символическая ссылка (Soft) | Жесткая ссылка (Hard) |
| :--- | :--- | :--- |
| **Команда** | `ln -s ...` | `ln ...` |
| **Что это?** | "Ярлык", отдельный файл-указатель | "Второе имя" для того же файла |
| **Удаление оригинала** | Ссылка становится "битой" | Ничего не происходит, файл доступен |
| **Можно для папок?** | **Да** | **Нет** |
| **Можно между дисками?** | **Да** | **Нет** |
| **`ls -l` показывает** | `l` в начале и `->` | Увеличенный счетчик ссылок (цифра) |

**Фишки и практическое применение:**

*   **Симлинки** используются повсеместно. Например, когда ты устанавливаешь программу, ее исполняемый файл может лежать в `/opt/cool_app/bin/start`, а в `/usr/bin/` создается симлинк `cool_app -> /opt/cool_app/bin/start`, чтобы ты мог запускать ее из любого места просто по имени `cool_app`.
*   **Симлинки** идеальны для управления конфигурационными файлами (dotfiles). Ты можешь хранить все свои конфиги (`.bashrc`, `.vimrc`) в одной папке на Dropbox/Git, а в домашней директории создать на них симлинки.
*   **Жесткие ссылки** часто используются для создания "бесплатных" бэкапов. Некоторые программы резервного копирования (например, `rsync` с опцией `--link-dest`) при создании инкрементального бэкапа не копируют файлы, которые не изменились, а создают на них жесткие ссылки из предыдущего бэкапа. Это экономит огромное количество места на диске.

---

### Часть 2: Права доступа и команда `chmod`

В Linux, как в многопользовательской системе, крайне важно контролировать, кто и что может делать с файлами. Для этого и существует система прав доступа.

#### Как посмотреть права?

Команда `ls -l` — твой лучший друг.
```bash
ls -l my_script.sh
# -rwxr-xr-- 1 user developers 1200 окт 26 15:30 my_script.sh
```

Давай разберем эту строку по частям: `-rwxr-xr--`

*   **Первый символ:** тип файла.
    *   `-` : обычный файл.
    *   `d` : директория (папка).
    *   `l` : символическая ссылка (link).
*   **Следующие 9 символов:** это и есть права доступа, разделенные на 3 группы по 3 символа.

| Группа 1 | Группа 2 | Группа 3 |
| :--- | :--- | :--- |
| `rwx` | `r-x` | `r--` |
| **Владелец (User)** | **Группа (Group)** | **Остальные (Others)** |

**Кто есть кто?**
*   **User (u):** Владелец файла. В нашем примере это `user`.
*   **Group (g):** Группа-владелец. Все пользователи, входящие в эту группу, получают эти права. В примере это `developers`.
*   **Others (o):** Все остальные пользователи системы.

**Что означают сами права?**
*   **`r` (read, чтение):**
    *   Для файла: можно просмотреть его содержимое (`cat`, `less`).
    *   Для папки: можно просмотреть список файлов в ней (`ls`).
*   **`w` (write, запись):**
    *   Для файла: можно изменять его содержимое (`nano`, `echo >>`).
    *   Для папки: можно **создавать, удалять и переименовывать файлы внутри этой папки**. (Очень важный момент! Право на удаление файла определяется правами на папку, в которой он лежит, а не на сам файл).
*   **`x` (execute, исполнение):**
    *   Для файла: можно запустить его как программу или скрипт.
    *   Для папки: можно войти в нее (`cd`). Без права `x` на папку ты не сможешь получить доступ к ее содержимому, даже если у тебя есть право `r`.

#### Как изменить права? Команда `chmod`

`chmod` (change mode) — команда для изменения прав. У нее есть два синтаксиса: символьный (проще для запоминания) и числовой (быстрее для написания).

##### 1. Символьный режим (Буквенный)

Формула: `chmod [кого затрагиваем][действие][какие права] имя_файла`

*   **Кого затрагиваем:** `u` (user), `g` (group), `o` (others), `a` (all - все сразу).
*   **Действие:** `+` (добавить право), `-` (убрать право), `=` (установить право, убрав все остальные для этой группы).
*   **Какие права:** `r`, `w`, `x`.

**Примеры:**
*   `chmod u+x my_script.sh` — **Д**ать **в**ладельцу (**u**) право на **и**сполнение (**+x**). Самая частая операция для скриптов.
*   `chmod g-w private_data.txt` — **З**абрать у **г**руппы (**g**) право на **з**апись (**-w**).
*   `chmod o=r public_info.txt` — **У**становить для **о**стальных (**o**) только право на **ч**тение (**=r**), убрав `w` и `x`, если они были.
*   `chmod a+r common_file.txt` — **Д**ать **в**сем (**a**) право на **ч**тение (**+r**).
*   `chmod ug+w,o-w shared_file` — Можно комбинировать: дать `user` и `group` право на запись, а у `others` забрать.

##### 2. Числовой режим (Восьмеричный)

Вот мы и добрались до "магии чисел". Этот способ выглядит сложнее, но он очень быстрый и используется повсеместно.

Идея основана на двоичной системе счисления. Каждому праву присваивается числовое значение (степень двойки):
*   `r` (read) = **4** (двоичное `100`)
*   `w` (write) = **2** (двоичное `010`)
*   `x` (execute) = **1** (двоичное `001`)

Чтобы получить итоговое число для группы (владелец, группа, остальные), мы просто **складываем** значения нужных нам прав.

*   `rwx` = 4 + 2 + 1 = **7**
*   `rw-` = 4 + 2 + 0 = **6**
*   `r-x` = 4 + 0 + 1 = **5**
*   `r--` = 4 + 0 + 0 = **4**
*   `--x` = 0 + 0 + 1 = **1**
*   `---` = 0 + 0 + 0 = **0**

Команда `chmod` принимает трехзначное число. Каждая цифра соответствует своей группе:

**`chmod [цифра для User][цифра для Group][цифра для Others] имя_файла`**

**Примеры:**

*   `chmod 755 my_script.sh`
    *   **7** для владельца: `rwx` (4+2+1) — может всё.
    *   **5** для группы: `r-x` (4+1) — могут читать и исполнять.
    *   **5** для остальных: `r-x` (4+1) — тоже могут читать и исполнять.
    *   *Типичные права для исполняемых файлов и скриптов.*

*   `chmod 644 my_document.txt`
    *   **6** для владельца: `rw-` (4+2) — может читать и изменять.
    *   **4** для группы: `r--` (4) — могут только читать.
    *   **4** для остальных: `r--` (4) — тоже могут только читать.
    *   *Стандартные права для большинства обычных файлов.*

*   `chmod 600 private_key`
    *   **6** для владельца: `rw-` (4+2) — может читать и писать.
    *   **0** для группы: `---` (0) — ничего не могут.
    *   **0** для остальных: `---` (0) — ничего не могут.
    *   *Типичные права для очень чувствительных файлов, например, SSH-ключей.*

*   `chmod 777 public_folder`
    *   **7** для всех. Все могут всё: читать, писать, исполнять (входить в папку, создавать и удалять в ней файлы).
    *   **Будь осторожен!** Такие права дают полный доступ кому угодно и считаются небезопасными. Используй их, только если точно знаешь, что делаешь (например, для временной папки `/tmp`).

#### Фишки и полезные опции `chmod`

*   **Рекурсивное изменение:** `chmod -R`
    Команда `chmod -R 755 my_project_folder` применит права `755` ко **всем** файлам и подпапкам внутри `my_project_folder`. Это очень мощно, но и опасно. Неправильное использование может "сломать" всю систему.

*   **Специальные права (Special Permissions): SUID, SGID, Sticky Bit**
    Это продвинутая тема, но раз ты просил фишки — вот они! Иногда ты видишь права не `rwx`, а `rws` или `rwt`.
    *   **SUID (Set User ID)**: `chmod u+s` или `chmod 4755`. Когда такой файл запускается, он исполняется с правами **владельца файла**, а не того, кто его запустил. Пример: команда `passwd`. Обычный пользователь запускает ее, чтобы сменить свой пароль, но для этого ей нужно записать изменения в системный файл `/etc/shadow`, который может редактировать только `root`. Благодаря SUID-биту, `passwd` на время своего выполнения "становится рутом".
    *   **SGID (Set Group ID)**: `chmod g+s` или `chmod 2775`. Для файла — работает аналогично SUID, но с правами группы. Для **папки** — все новые файлы и папки, созданные внутри, будут автоматически принадлежать той же **группе**, что и родительская папка (а не основной группе пользователя, который их создал). Это супер-полезно для общих папок проектов!
    *   **Sticky Bit**: `chmod +t` или `chmod 1777`. Работает только для папок. Если на папку установлен "липкий бит", то файлы внутри этой папки могут удалять или переименовывать **только их владельцы** (и `root`), даже если у всех есть право на запись (`w`) в эту папку. Классический пример — папка `/tmp`. Любой может создать там файл, но никто не может удалить чужой.

Надеюсь, этот детальный разбор поможет тебе увереннее чувствовать себя в командной строке! Практикуйся, создавай файлы, меняй права, делай ссылки — и всё это очень быстро войдет в привычку. Удачи




--------------------------




Отличный настрой! Это именно тот подход, который нужен, чтобы стать профессионалом. Разложим все по полочкам: от базовых понятий до "фишек", которые отличают новичка от опытного пользователя. Поехали!

### Часть 1: Процессы. Душа системы

#### 1.1. Что такое процесс?

Представь себе рецепт (это программа, например, `/bin/bash` или `firefox`). Пока он лежит в книге, это просто текст. Но как только ты начинаешь готовить по нему — отмеряешь ингредиенты, включаешь плиту, смешиваешь — рецепт "оживает".

**Процесс — это запущенная на выполнение программа.**

У каждого процесса есть уникальные атрибуты, главные из которых:
*   **PID (Process ID)**: Уникальный номер, как паспорт для процесса. Система использует его для управления процессом.
*   **PPID (Parent Process ID)**: PID родительского процесса. Каждый процесс (кроме самого первого, `init` или `systemd` с PID 1) был запущен другим процессом. Это создает древовидную структуру.
*   **Пользователь (User)**: От чьего имени запущен процесс. Это определяет его права доступа к файлам и другим ресурсам.
*   **Состояние (State)**: Работает ли он сейчас (`R` - Running), спит ли в ожидании чего-то (`S` - Sleeping), остановлен (`T` - Stopped) или стал "зомби" (`Z` - Zombie).

---

#### 1.2. Как просматривать процессы: `ps`

`ps` (process status) — это основной инструмент для получения "снимка" текущих процессов.

**Базовое использование:**

```bash
ps
```
Выведет только процессы, запущенные в вашем текущем терминале. Малоинформативно.

**Как делают профессионалы: `ps aux` и `ps -ef`**

Это две самые популярные и мощные комбинации. Они показывают ВСЕ процессы в системе.

1.  **Стиль BSD (чаще всего используется в Linux): `ps aux`**

    ```bash
    ps aux
    ```

    *   `a` — показать процессы всех пользователей.
    *   `u` — показать в "user-oriented" (понятном для пользователя) формате с дополнительными колонками.
    *   `x` — показать процессы, не привязанные к терминалу (системные службы, демоны).

    **Разбор колонок `ps aux`:**
    *   `USER`: Пользователь, от имени которого запущен процесс.
    *   `PID`: Уникальный идентификатор процесса.
    *   `%CPU`: Процент использования CPU.
    *   `%MEM`: Процент использования оперативной памяти (RAM).
    *   `VSZ`: Виртуальный размер памяти (в килобайтах).
    *   `RSS`: Реальный размер памяти, занимаемый в RAM (в килобайтах). **Очень важный показатель!**
    *   `TTY`: Терминал, к которому привязан процесс. `?` означает, что процесс не привязан к терминалу.
    *   `STAT`: Состояние процесса (`S` - sleep, `R` - running, `Z` - zombie, `T` - stopped, `+` - в основной группе процессов).
    *   `START`: Время запуска процесса.
    *   `TIME`: Общее время использования CPU процессом.
    *   `COMMAND`: Команда, которая запустила процесс.

2.  **Стиль SystemV/POSIX: `ps -ef`**

    ```bash
    ps -ef
    ```
    *   `-e` — показать все процессы (`e`very).
    *   `-f` — показать в полном формате (`f`ull).

    **Разбор колонок `ps -ef`:**
    *   `UID`: Имя пользователя (похоже на `USER`).
    *   `PID`: Идентификатор процесса.
    *   `PPID`: Идентификатор родительского процесса. **Очень полезно для отслеживания зависимостей!**
    *   `C`: Использование CPU (похоже на `%CPU`).
    *   `STIME`: Время запуска (похоже на `START`).
    *   `TTY`: Терминал.
    *   `TIME`: Время использования CPU.
    *   `CMD`: Команда (похоже на `COMMAND`).

**Какой формат выбрать?** Дело вкуса. `ps aux` хорош для быстрой оценки потребления ресурсов (`%CPU`, `%MEM`). `ps -ef` незаменим, когда нужно увидеть иерархию процессов (кто кого запустил) благодаря колонке `PPID`.

#### 1.3. Эффективная работа с `ps`: Фишки и трюки

1.  **Сортировка (Ключевая фишка!)**

    Хотите найти, кто больше всех "ест" память или CPU? Используйте флаг `--sort`.

    *   Найти 10 процессов, потребляющих больше всего памяти:
        ```bash
        ps aux --sort=-%mem | head -n 11
        ```
        Знак `-` перед `%mem` означает сортировку по убыванию. `head -n 11` выводит первые 11 строк (1 строка заголовка + 10 процессов).

    *   Найти 10 процессов, потребляющих больше всего CPU:
        ```bash
        ps aux --sort=-%cpu | head -n 11
        ```

2.  **Пользовательский формат вывода (`-o`)**

    Вам не нужны все колонки, а нужны только PID, пользователь и команда? Легко!

    ```bash
    ps -eo pid,user,cmd
    ```
    `e` нужно, чтобы показать все процессы. `-o` (или `--format`) задает нужные колонки.

    *   **Про-трюк:** Показать дерево процессов (кто кого запустил) в ASCII-графике.
        ```bash
        ps -ef --forest
        ```
        Или более мощный вариант:
        ```bash
        ps axjf
        ```

3.  **Поиск нужного процесса**

    Классический способ — использовать `grep`.

    ```bash
    ps aux | grep nginx
    ```
    Это найдет все строки, где встречается "nginx".

    *   **Фишка:** В выводе вы увидите и сам процесс `grep nginx`. Чтобы его отфильтровать:
        ```bash
        ps aux | grep nginx | grep -v grep
        ```
        (`-v` инвертирует поиск, т.е. убирает строки с `grep`).
    *   **Более изящный способ:**
        ```bash
        ps aux | grep '[n]ginx'
        ```
        Такой трюк с квадратными скобками не дает `grep` найти самого себя.

4.  **Современный подход: `pgrep`**

    Вместо `ps | grep` лучше использовать утилиту `pgrep`, которая создана специально для этого.

    *   Просто найти PID процесса по имени:
        ```bash
        pgrep firefox
        ```
    *   **Фишка:** `pgrep` умеет больше.
        *   `-l`: Показать имя процесса вместе с PID.
        *   `-a`: Показать полную командную строку.
        *   `-u`: Искать процессы конкретного пользователя (`pgrep -u root`).
        *   `-f`: Искать по всей командной строке, а не только по имени процесса.

        Пример: Найти PID и команду всех процессов `python`, запущенных пользователем `www-data`:
        ```bash
        pgrep -af -u www-data python
        ```

#### 1.4. Интерактивный мониторинг: `top` и `htop`

*   **`top`**: Классический диспетчер задач в реальном времени. Запустите его, и он будет обновлять список процессов.
    *   **Полезные команды внутри `top`:**
        *   `M` (Shift+m): Сортировать по использованию памяти.
        *   `P` (Shift+p): Сортировать по использованию CPU (по умолчанию).
        *   `k`: Убить процесс (спросит PID и сигнал).
        *   `u`: Показать процессы конкретного пользователя (спросит имя).
        *   `1`: Показать загрузку каждого ядра CPU по отдельности.
        *   `q`: Выйти.

*   **`htop` (highly recommended!)**: Улучшенная, цветная и интерактивная версия `top`. Если её нет, обязательно установите (`sudo apt install htop` или `sudo yum install htop`).
    *   **Преимущества:**
        *   Наглядные цветные индикаторы CPU, памяти, swap.
        *   Удобная навигация стрелками.
        *   Можно скроллить список процессов.
        *   `F4`: Фильтр по имени.
        *   `F5`: Древовидный вид.
        *   `F9`: Убить процесс (выбор сигнала из меню).
        *   `F7`, `F8`: Повысить/понизить приоритет процесса (nice).

---

### Часть 2: Команда `who`. Кто на борту?

Команда `who` показывает, кто из пользователей в данный момент вошел в систему.

**Базовое использование:**

```bash
who
```
Вывод будет примерно таким:
```
user1    tty1         2023-10-27 10:30
user2    pts/0        2023-10-27 11:00 (:0.0)
```
*   `user1`: Имя пользователя.
*   `tty1`: Физический терминал (консоль).
*   `pts/0`: Псевдотерминал (например, SSH-сессия или эмулятор терминала в графической среде).
*   `2023-10-27 11:00`: Дата и время входа.
*   `(:0.0)`: IP-адрес или дисплей, с которого зашли (если доступно).

**Полезные аргументы и "фишки":**

*   `who -H` или `who --heading`
    Добавляет заголовки к колонкам. Очень удобно для читаемости.

    ```bash
    who -H
    NAME     LINE         TIME         COMMENT
    user1    tty1         2023-10-27 10:30
    ```
*   `who -b` или `who --boot`
    Показывает время последней загрузки системы.

    ```bash
    who -b
             system boot  2023-10-25 08:00
    ```
*   `who -r` или `who --runlevel`
    Показывает текущий уровень выполнения (runlevel).

*   `who -q` или `who --count`
    Краткий формат: только имена и общее количество.

    ```bash
    who -q
    user1 user2
    # users=2
    ```
*   `who -u` или `who --users`
    **Очень полезная фишка!** Добавляет информацию о времени простоя (`IDLE`) и PID сессии.
    ```bash
    who -uH
    NAME     LINE         TIME         IDLE          PID COMMENT
    user1    pts/0        2023-10-27 11:00   .          12345 (192.168.1.10)
    user2    pts/1        2023-10-27 12:00 01:15       23456 (192.168.1.11)
    ```
    *   `IDLE`: `.` означает, что пользователь был активен в последнюю минуту. `01:15` означает, что пользователь неактивен 1 час 15 минут. Это помогает понять, "брошена" ли сессия.
    *   `PID`: PID командного интерпретатора (shell) пользователя.

*   `who am i`
    Специальная форма, которая показывает информацию только о вашей текущей сессии. Эквивалентно `who -m`.

---

### Часть 3: Сигналы. Язык общения с процессами

#### 3.1. Что такое сигнал?

**Сигнал** — это асинхронное уведомление, посылаемое процессу для того, чтобы сообщить ему о каком-либо событии. Это основной способ управления процессами "извне".

Когда процесс получает сигнал, он может:
1.  **Выполнить действие по умолчанию:** Например, для сигнала "убить" — завершиться.
2.  **Обработать сигнал:** Программа может быть написана так, чтобы "перехватить" сигнал и выполнить свою логику (например, корректно сохранить файлы перед завершением).
3.  **Игнорировать сигнал:** Просто проигнорировать его (кроме нескольких особых сигналов).

#### 3.2. Как отправить сигнал: `kill`, `pkill`, `killall`

Основная команда — `kill`. Несмотря на название, она может отправлять ЛЮБОЙ сигнал, а не только "убивающий".

**Синтаксис:** `kill -<СИГНАЛ> <PID>`

`<СИГНАЛ>` может быть номером или именем. Посмотреть все сигналы:
```bash
kill -l
```

**Самые важные сигналы, которые должен знать каждый профессионал:**

| Номер | Имя        | Что делает и для чего нужен                                                                                                | Как отправить (пример для PID 12345)           |
| :---- | :--------- | :------------------------------------------------------------------------------------------------------------------------- | :--------------------------------------------- |
| **1** | **SIGHUP** | **Hang Up**. Исторически — разрыв связи с терминалом. **Современное использование:** заставить демона (службу) **перечитать свой конфигурационный файл**, не останавливая работу. Очень важно! | `kill -HUP 12345` или `kill -1 12345`          |
| **2** | **SIGINT** | **Interrupt**. Сигнал прерывания с клавиатуры. То, что посылается, когда вы нажимаете **`Ctrl+C`**. Процесс может его перехватить. | `kill -INT 12345` или `kill -2 12345`          |
| **9** | **SIGKILL**| **Kill**. "Жестокое" убийство. Этот сигнал **нельзя перехватить или проигнорировать**. Ядро системы просто убирает процесс из памяти. **Используйте как последнее средство!** Процесс не успеет сохранить данные. | `kill -KILL 12345` или `kill -9 12345`         |
| **15**| **SIGTERM**| **Terminate**. Сигнал завершения. **Это сигнал по умолчанию для `kill`**. Это "вежливая" просьба завершиться. Процесс может перехватить его, сохранить данные, закрыть соединения и чисто завершиться. | `kill 12345` (по умолчанию) или `kill -15 12345`|
| **18**| **SIGCONT**| **Continue**. Продолжить выполнение остановленного процесса.                                                               | `kill -CONT 12345` или `kill -18 12345`        |
| **19**| **SIGSTOP**| **Stop**. Немедленная остановка (пауза) процесса. Его **нельзя перехватить или проигнорировать**. Процесс "замораживается". Аналог `Ctrl+Z`. | `kill -STOP 12345` или `kill -19 12345`        |

#### 3.3. Практический рабочий процесс и "фишки"

**Сценарий 1: Нужно перезагрузить конфиг веб-сервера `nginx`**

1.  Находим PID главного процесса `nginx`.
    ```bash
    pgrep -o nginx
    # Допустим, вывелось 8888
    ```
2.  Отправляем сигнал SIGHUP.
    ```bash
    kill -HUP 8888
    ```
    Nginx перечитает свои `.conf` файлы, не прерывая обслуживание текущих клиентов. Это профессиональный способ обновления конфигурации.

**Сценарий 2: Программа зависла и не отвечает.**

1.  Находим её PID.
    ```bash
    pgrep -l firefox
    # Допустим, 12345 firefox
    ```
2.  **Шаг 1: Попытка вежливого завершения (SIGTERM).**
    ```bash
    kill 12345
    ```
    Ждем несколько секунд. Проверяем, исчез ли процесс (`pgrep firefox`). Если да — отлично.

3.  **Шаг 2: Если процесс не завершился, используем "тяжелую артиллерию" (SIGKILL).**
    ```bash
    kill -9 12345
    ```
    Это почти всегда срабатывает.

**Сценарий 3: Нужно временно остановить ресурсоемкий процесс**

Допустим, у вас компилируется большой проект, и вам срочно нужны все ресурсы CPU для другой задачи.

1.  Находим PID процесса компиляции (например, `make`).
    ```bash
    pgrep make
    # Допустим, 22334
    ```
2.  Ставим его на паузу.
    ```bash
    kill -STOP 22334
    ```
3.  Делаем свою срочную работу.
4.  Возобновляем процесс компиляции.
    ```bash
    kill -CONT 22334
    ```

**Продвинутые команды для отправки сигналов:**

*   **`pkill`**: Отправляет сигнал процессам, найденным по имени. Не нужно искать PID вручную!

    *   Вежливо попросить все процессы `firefox` завершиться:
        ```bash
        pkill -TERM firefox
        ```
    *   Жестоко убить все процессы, принадлежащие пользователю `baduser`:
        ```bash
        pkill -9 -u baduser
        ```

*   **`killall`**: Похожа на `pkill`, но обычно требует точного совпадения имени процесса.

    *   Перезагрузить конфиг `nginx`:
        ```bash
        killall -HUP nginx
        ```

### Итог для будущего профессионала

1.  **Процессы — это живые программы.** Управляй ими через PID.
2.  **`ps aux` и `ps -ef` — твои глаза.** Используй `--sort` и `-o` для кастомизации. Забудь `ps | grep`, используй `pgrep`.
3.  **`htop` — твой интерактивный пульт управления.** Установи и используй его вместо `top`.
4.  **`who -uH` — быстрый способ узнать, кто в системе и не простаивает ли он.**
5.  **Сигналы — твой голос.** `kill` — не только "убить".
    *   Всегда начинай с вежливого `SIGTERM` (15).
    *   `SIGKILL` (9) — это крайняя мера.
    *   `SIGHUP` (1) — твой друг для перезагрузки конфигураций.
    *   `SIGSTOP` (19) / `SIGCONT` (18) — для постановки на паузу.
6.  **`pkill` и `killall` экономят время**, позволяя работать с именами, а не с PID.

Практикуйся! Запускай разные программы, смотри на них в `htop`, находи их PID через `pgrep`, отправляй им сигналы `STOP` и `CONT`. Чем больше ты будешь это делать, тем быстрее это войдет в привычку. Удачи






------------------


Конечно! Мы продолжаем наше погружение в мир командной строки. Скрипты — это то, что превращает пользователя в настоящего системного администратора или DevOps-инженера. Это магия автоматизации. Поехали!

### Часть 1: Основы основ. Ваш первый скрипт

#### 1.1. Что такое Shell-скрипт?

**Shell-скрипт** (или сценарий командной оболочки) — это простой текстовый файл, содержащий последовательность команд, которые может выполнить командный интерпретатор (shell), такой как `bash`. Вместо того чтобы вводить команды одну за другой, вы записываете их в файл и запускаете этот файл.

#### 1.2. Создание и запуск

1.  **Шебанг (Shebang): `#!`**
    Самая первая строка в любом хорошем скрипте. Она говорит системе, какой интерпретатор использовать для выполнения этого файла.

    `#!/bin/bash` — самая распространенная. Означает "использовать bash".
    `#!/bin/sh` — использовать стандартный `sh`. Более переносимый, но с меньшим количеством "фишек" bash.
    `#!/usr/bin/env python3` — использовать python3 для выполнения скрипта.

    **Профессиональный совет:** Всегда используйте шебанг. Это делает ваши скрипты предсказуемыми.

2.  **Создаем файл:**
    Откройте текстовый редактор (например, `nano`, `vim` или `vscode`) и создайте файл, например, `my_script.sh`.

    ```bash
    nano my_script.sh
    ```

3.  **Пишем код:**
    Вставьте это в файл:

    ```bash
    #!/bin/bash

    # Это комментарий. Интерпретатор его игнорирует.
    echo "Привет, мир скриптов!"
    echo "Сегодняшняя дата: $(date)"
    ```

4.  **Делаем файл исполняемым:**
    По умолчанию текстовые файлы не могут быть запущены. Нужно дать право на выполнение (`x` - execute).

    ```bash
    chmod +x my_script.sh
    ```

5.  **Запускаем скрипт:**
    Если скрипт находится в текущей директории, его нужно запускать так:

    ```bash
    ./my_script.sh
    ```
    Точка-слэш (`./`) явно указывает системе, что файл нужно искать в текущей директории. Это мера безопасности.

    **Результат выполнения:**
    ```
    Привет, мир скриптов!
    Сегодняшняя дата: Пт 27 окт 2023 15:30:00 MSK
    ```

---

### Часть 2: Переменные и параметры

#### 2.1. Переменные

Переменные — это контейнеры для хранения данных.

*   **Присваивание:** `ИМЯ=ЗНАЧЕНИЕ`. **ВАЖНО: без пробелов вокруг знака `=`!**
*   **Использование:** `$ИМЯ` или `${ИМЯ}`. Фигурные скобки полезны, чтобы отделить имя переменной от остального текста: `echo "${USER}name"`.

```bash
#!/bin/bash

NAME="Алекс"
echo "Привет, $NAME!" # Выведет: Привет, Алекс!

# Командная подстановка: результат команды кладется в переменную
FILES=$(ls -l)
echo "Содержимое директории:"
echo "$FILES" # ВАЖНО: всегда заключайте переменные в кавычки при выводе!

# Арифметические выражения
A=5
B=10
SUM=$((A + B))
echo "Сумма A и B: $SUM" # Выведет: Сумма A и B: 15
```
**Фишка:** Почему кавычки важны? Если переменная `$FILES` содержит имена файлов с пробелами, `echo $FILES` выведет их в одну строку. А `echo "$FILES"` сохранит исходное форматирование и переносы строк. Всегда используйте кавычки: `"$VAR"`.

#### 2.2. Специальные переменные (параметры скрипта)

Это "волшебные" переменные, которые Bash устанавливает автоматически. Они — ключ к созданию гибких скриптов.

Предположим, мы запускаем скрипт так: `./my_script.sh first_arg "второй аргумент" 3`

*   `$0`: Имя самого скрипта. (`./my_script.sh`)
*   `$1`, `$2`, `$3`, ...: Аргументы, переданные скрипту. (`$1` будет "first_arg", `$2` будет "второй аргумент", `$3` будет "3").
*   `$#`: Количество переданных аргументов. (В нашем случае `3`).
*   `$@`: Все аргументы как отдельные "слова" в кавычках. (`"first_arg" "второй аргумент" "3"`). **Это предпочтительный способ** для перебора аргументов.
*   `$*`: Все аргументы как одна строка. (`"first_arg второй аргумент 3"`).
*   `$?`: **Код возврата (Exit Status)** последней выполненной команды. `0` — успех, любое другое число (от 1 до 255) — ошибка. **Супер-важная переменная для контроля выполнения!**
*   `$$`: PID (ID процесса) текущего скрипта. Полезно для создания уникальных временных файлов.

**Пример скрипта `show_args.sh`:**

```bash
#!/bin/bash

echo "Имя скрипта: $0"
echo "Первый аргумент: $1"
echo "Второй аргумент: $2"
echo "Количество аргументов: $#"
echo "Все аргументы (через \$@): $@"

# Проверка кода возврата
ls /non_existent_directory
echo "Код возврата 'ls': $?" # Выведет ненулевое значение

ls /
echo "Код возврата 'ls': $?" # Выведет 0
```
Запуск: `./show_args.sh hello world`

---

### Часть 3: Управление потоком. Логика скрипта

#### 3.1. Условные операторы: `if`, `else`, `elif`

Синтаксис:
```bash
if [ условие ]; then
  # команды, если условие истинно
elif [ другое_условие ]; then
  # команды, если первое условие ложно, а это истинно
else
  # команды, если все условия ложны
fi # Закрывающий тег
```

**Ключевой момент: `[ ... ]` (или `test`) и `[[ ... ]]`**

`[` — это не часть синтаксиса, а **команда** (синоним команды `test`). Поэтому **пробелы вокруг скобок обязательны!**
`[[ ... ]]` — это более современная и мощная конструкция, встроенная в `bash`. **Рекомендуется использовать именно её!** Она умнее работает со строками и не требует кавычек для переменных внутри.

**Операторы сравнения (самые важные):**

| Категория   | Оператор      | Что делает                                    | Пример (`[[ ... ]]`)          |
| :---------- | :------------ | :-------------------------------------------- | :---------------------------- |
| **Строки**  | `==` или `=`  | Равно                                         | `[[ "$STR1" == "$STR2" ]]`     |
|             | `!=`          | Не равно                                      | `[[ "$STR1" != "$STR2" ]]`     |
|             | `-z`          | Строка пустая (Zero length)                   | `[[ -z "$STR" ]]`             |
|             | `-n`          | Строка не пустая (Non-zero length)            | `[[ -n "$STR" ]]`             |
| **Числа**   | `-eq`         | Равно (EQual)                                 | `[[ "$NUM" -eq 10 ]]`         |
|             | `-ne`         | Не равно (Not Equal)                          | `[[ "$NUM" -ne 10 ]]`         |
|             | `-gt`         | Больше (Greater Than)                         | `[[ "$NUM" -gt 10 ]]`         |
|             | `-ge`         | Больше или равно (Greater or Equal)           | `[[ "$NUM" -ge 10 ]]`         |
|             | `-lt`         | Меньше (Less Than)                            | `[[ "$NUM" -lt 10 ]]`         |
|             | `-le`         | Меньше или равно (Less or Equal)              | `[[ "$NUM" -le 10 ]]`         |
| **Файлы**   | `-e`          | Файл или директория существует (Exists)         | `[[ -e "/path/to/file" ]]`    |
|             | `-f`          | Это обычный файл (File)                       | `[[ -f "/path/to/file" ]]`    |
|             | `-d`          | Это директория (Directory)                    | `[[ -d "/path/to/dir" ]]`     |
|             | `-r`          | Файл существует и доступен для чтения (Readable) | `[[ -r "/path/to/file" ]]`    |
| **Логика**  | `&&`          | ЛОГИЧЕСКОЕ И                                  | `[[ $A -gt 5 && $B -lt 10 ]]` |
|             | `||`          | ЛОГИЧЕСКОЕ ИЛИ                                | `[[ $A -eq 1 || $B -eq 1 ]]`  |
|             | `!`           | ЛОГИЧЕСКОЕ НЕ                                 | `[[ ! -f "/path/to/file" ]]`  |

**Пример использования `if`:**

```bash
#!/bin/bash

# Проверим, что скрипту передали ровно один аргумент
if [[ $# -ne 1 ]]; then
  echo "Ошибка: Скрипт требует ровно один аргумент (имя файла)."
  exit 1 # Завершаем скрипт с кодом ошибки
fi

FILENAME="$1"

if [[ -f "$FILENAME" ]]; then
  echo "Файл '$FILENAME' существует."
  if [[ -r "$FILENAME" ]]; then
    echo "И у вас есть права на его чтение."
  fi
else
  echo "Файл '$FILENAME' не найден."
fi
```
**Профессиональный совет:** Проверяйте код возврата `$?` вместо флагов. Это более "unix-way".
```bash
# Плохо
grep "word" file > /dev/null
if [[ $? -eq 0 ]]; then
  echo "Слово найдено"
fi

# Хорошо и лаконично
if grep -q "word" file; then # -q подавляет вывод, меняет только код возврата
  echo "Слово найдено"
fi
```

#### 3.2. Множественный выбор: `case`

Удобная замена длинным цепочкам `if-elif-else`, когда нужно проверить переменную на несколько конкретных значений.

```bash
#!/bin/bash

case "$1" in
  start)
    echo "Запускаем сервис..."
    # команды для запуска
    ;;
  stop)
    echo "Останавливаем сервис..."
    # команды для остановки
    ;;
  restart)
    echo "Перезапускаем сервис..."
    # команды для перезапуска
    ;;
  *) # Шаблон * соответствует всему остальному
    echo "Использование: $0 {start|stop|restart}"
    exit 1
    ;;
esac # 'case' наоборот
```

---

### Часть 4: Циклы. Повторяющиеся задачи

#### 4.1. Цикл `for`

Идеален для перебора списка элементов.

**Перебор строк:**
```bash
for NAME in "Иван" "Мария" "Петр"; do
  echo "Привет, $NAME!"
done
```
**Перебор файлов (очень частый сценарий):**
```bash
# Создать резервные копии всех .conf файлов
for FILE in *.conf; do
  cp "$FILE" "$FILE.bak"
  echo "Создана копия для $FILE"
done
```
**C-подобный цикл (для `bash`):**
```bash
for (( i=1; i<=5; i++ )); do
  echo "Счетчик: $i"
done
```

#### 4.2. Цикл `while`

Выполняется, пока условие истинно. Идеален для чтения файлов построчно.

```bash
#!/bin/bash
# Скрипт нумерует строки в файле

if [[ $# -ne 1 || ! -f "$1" ]]; then
  echo "Укажите существующий файл!"
  exit 1
fi

LINE_NUM=1
# Профессиональный трюк: `while read -r line`
# -r предотвращает интерпретацию обратных слэшей в строке
while read -r LINE; do
  echo "${LINE_NUM}: ${LINE}"
  ((LINE_NUM++)) # Увеличиваем счетчик
done < "$1" # Перенаправляем содержимое файла на вход цикла
```

#### 4.3. Цикл `until`

Противоположность `while`. Выполняется, пока условие ложно.
```bash
# Ждем, пока сервис поднимется и начнет отвечать
until curl -s http://localhost:8080 > /dev/null; do
  echo "Сервис еще не доступен, ждем 5 секунд..."
  sleep 5
done
echo "Сервис запущен!"
```

---

### Часть 5: Функции

Функции позволяют группировать код для повторного использования.

```bash
#!/bin/bash

# Определение функции
log() {
  # $1, $2 - это аргументы, переданные функции, а не скрипту
  local LEVEL="$1"
  local MESSAGE="$2"
  echo "$(date '+%Y-%m-%d %H:%M:%S') [${LEVEL}] - ${MESSAGE}"
}

# Использование функции
log "INFO" "Скрипт запущен."

# Проверяем, существует ли файл
FILE="/var/log/syslog"
if [[ -f "$FILE" ]]; then
  log "INFO" "Файл $FILE найден."
else
  log "ERROR" "Файл $FILE не найден!"
  exit 1
fi

log "INFO" "Скрипт завершен."
```
**Фишка:** `local` объявляет переменную, видимую только внутри функции. Это предотвращает случайное изменение глобальных переменных и является хорошей практикой.

---

### Часть 6: Переменные окружения vs. Shell-переменные

*   **Shell-переменная:** `MYVAR="hello"`. Видна только в текущем shell. Если из этого скрипта запустить другой, он не увидит `MYVAR`.
*   **Переменная окружения:** `export MYVAR="hello"`. Видна в текущем shell **и во всех дочерних процессах**, которые он запускает.

```bash
# script1.sh
#!/bin/bash
SHELL_VAR="Я только здесь"
export ENV_VAR="Я везде"
./script2.sh

# script2.sh
#!/bin/bash
echo "Shell переменная из родителя: '$SHELL_VAR'" # Будет пусто
echo "Переменная окружения из родителя: '$ENV_VAR'" # Выведет "Я везде"
```

Самые известные переменные окружения: `PATH` (где искать команды), `HOME` (домашняя директория), `USER` (имя пользователя).

---

### Часть 7: Советы и фишки для профессионалов

1.  **"Безопасный режим" (Unofficial Strict Mode)**
    Начинайте каждый серьезный скрипт с этих строк. Они спасут вас от множества ошибок.
    ```bash
    set -e  # Прекращать выполнение при любой ошибке (ненулевом коде возврата)
    set -u  # Считать ошибкой использование необъявленной переменной
    set -o pipefail # Если в конвейере (pipe) команда упадет, весь конвейер считается упавшим
    ```

2.  **`shellcheck` — ваш лучший друг**
    Это статический анализатор кода для shell-скриптов. Он найдет сотни потенциальных проблем: пропущенные кавычки, неправильное использование `test`, опасные конструкции.
    Установите его (`sudo apt install shellcheck`) и проверяйте каждый свой скрипт: `shellcheck my_script.sh`. Есть плагины для всех популярных редакторов. **Это самый важный совет в этом разделе.**

3.  **Используйте `$(command)` вместо `` `command` ``**
    `$(command)` (командная подстановка) — современный синтаксис. Его можно вкладывать друг в друга (`$(echo $(date))`), и он более читаемый, чем обратные кавычки (backticks).

4.  **Комментируйте свой код**
    Скрипт, который понятен сегодня, через месяц может стать загадкой. Объясняйте, **почему** вы делаете что-то, а не только **что** вы делаете.

5.  **Создавайте временные файлы правильно**
    Не делайте так: `TMP_FILE=/tmp/my_temp_file`. Если два экземпляра скрипта запустятся одновременно, будет конфликт.
    Делайте так:
    ```bash
    # Создает безопасный временный файл и сохраняет путь в переменную
    TMP_FILE=$(mktemp)
    # Гарантирует удаление файла при выходе из скрипта (даже при ошибке)
    trap 'rm -f "$TMP_FILE"' EXIT

    echo "Мои временные данные" > "$TMP_FILE"
    # ... работа с файлом ...
    ```

Этот гайд — мощная база. Теперь ваша задача — практика. Начните с простых вещей: напишите скрипт для резервного копирования папки, для очистки старых логов, для проверки доступности сайтов. С каждым новым скриптом вы будете становиться все увереннее. Удачи в автоматизации